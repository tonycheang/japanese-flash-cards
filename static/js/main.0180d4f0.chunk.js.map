{"version":3,"sources":["CardDisplay.js","UserInputDisplay.js","App.js","serviceWorker.js","index.js"],"names":["CardDisplay","react_default","a","createElement","style","fontSize","margin","this","props","data","React","Component","inputFieldStyle","backgroundColor","textAlign","UserInputDisplay","align","width","input","autoFocus","ghost","placeholder","defaultText","value","onChange","Card","front","back","Object","classCallCheck","FlashCardApp","_this","possibleConstructorReturn","getPrototypeOf","call","handleInput","bind","assertThisInitialized","reportCorrectness","readForm","showAnswer","resetInputAfterTyping","resetInput","resetInputAfterReveal","defaultBackgroundColor","phonetic","cards","map","char","i","state","currentCard","Math","floor","length","random","typed","textColor","border","firstTimeTyping","window","addEventListener","removeEventListener","event","setState","key","justRevealed","curText","slice","test","typingTimer","clearTimeout","setTimeout","answer","toLowerCase","delay","nextCard","_this2","displayButton","card","es_button","type","onClick","class","src_CardDisplay","src_UserInputDisplay","Boolean","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0180d4f0.chunk.js","sourcesContent":["import React from 'react';\n\nclass CardDisplay extends React.Component {\n    render(){\n        return (\n            <div style={{fontSize: 70, margin: \"2%\"}}>\n                {this.props.data}\n            </div>\n        )\n    }\n}\n\nexport default CardDisplay;","import React from 'react';\nimport Input from 'antd/es/input';\n\nconst inputFieldStyle = {\n    backgroundColor: \"transparent\",\n    // border: \"none\",\n    fontSize: 20,\n    textAlign: \"center\"\n}\n\nclass UserInputDisplay extends React.Component {\n    render() {\n        return (\n            <div align=\"center\" style={{margin: \"2%\", width: \"80%\"}}>\n                <Input autoFocus ghost\n                    placeholder={this.props.defaultText}\n                    value={this.props.data}\n                    style={inputFieldStyle}\n                    onChange={this.props.onChange}>\n                </Input>\n            </div>\n        )\n    }\n}\n\nexport default UserInputDisplay;","import React from 'react';\nimport CardDisplay from './CardDisplay';\nimport UserInputDisplay from './UserInputDisplay';\nimport Button from 'antd/es/button'\nimport './App.css';\n\nclass Card {\n  constructor(front, back) {\n    this.front = front;\n    this.back = back;\n  }\n}\n\nclass FlashCardApp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handleInput = this.handleInput.bind(this);\n    this.reportCorrectness = this.reportCorrectness.bind(this);\n    this.readForm = this.readForm.bind(this);\n    this.showAnswer = this.showAnswer.bind(this);\n    this.resetInputAfterTyping = this.resetInput.bind(this, 500);\n    this.resetInputAfterReveal = this.resetInput.bind(this, 0, true);\n\n    this.defaultBackgroundColor = \"#FFFFFF\"\n    const phonetic = ['a', 'i', 'u', 'e', 'o',\n      'ka', 'ki', 'ku', 'ke', 'ko',\n      'sa', 'shi', 'su', 'se', 'so',\n      'ta', 'chi', 'tsu', 'te', 'to',\n      'na', 'ni', 'nu', 'ne', 'no',\n      'ha', 'hi', 'fu', 'he', 'ho',\n      'ma', 'mi', 'mu', 'me', 'mo',\n      'ya', 'yu', 'yo',\n      'ra', 'ri', 'ru', 're', 'ro',\n      'wa', 'wo', 'n'\n    ];\n    const hirgana = ['あ', 'い', 'う', 'え', 'お',\n      'か', 'き', 'く', 'け', 'こ',\n      'さ', 'し', 'す', 'せ', 'そ',\n      'た', 'ち', 'つ', 'て', 'と',\n      'な', 'に', 'ぬ', 'ね', 'の',\n      'は', 'ひ', 'ふ', 'へ', 'ほ',\n      'ま', 'み', 'む', 'め', 'も',\n      'や', 'ゆ', 'よ',\n      'ら', 'り', 'る', 'れ', 'ろ',\n      'わ', 'を', 'ん'\n    ];\n    this.cards = hirgana.map((char, i) => new Card(char, phonetic[i]));\n\n    // NOTE: show front essentially unused!\n    this.state = {\n      currentCard: this.cards[Math.floor(this.cards.length * Math.random())],\n      typed: \"\",\n      textColor: \"#000000\",\n      backgroundColor: this.defaultBackgroundColor,\n      border: \"1px solid\",\n      firstTimeTyping: true\n    }\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"keydown\", this.handleInput);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.handleInput);\n  }\n\n  handleInput(event) {\n    if (this.state.firstTimeTyping)\n      this.setState({ firstTimeTyping: false });\n\n    if (event.key === \"Enter\" || event.key === \" \") {\n      if (this.state.justRevealed)\n        this.resetInputAfterReveal();\n      else\n        this.showAnswer();\n    }\n\n    let curText = this.state.typed;\n    let isLetter = /^\\w$/;\n    if (event.key === \"Backspace\") {\n      if (curText.length > 0) {\n        this.setState({ typed: curText.slice(0, curText.length - 1) })\n      }\n    } else if (isLetter.test(event.key)) {\n      this.setState((state) => state.typed += event.key)\n    } else {\n      // Do not extend timer for input or report correctness\n      return;\n    }\n\n    // Extend the timer to recognize input if it exists, otherwise make one\n    if (this.state.typingTimer)\n      clearTimeout(this.state.typingTimer);\n    this.setState({ typingTimer: setTimeout(this.reportCorrectness, 300) });\n  }\n\n  readForm(event) {\n    // Temp holder while using window.addEventListener(\"keydown\", this.handleInput);\n    // console.log(event.target.value);\n  }\n\n  showAnswer(event) {\n    // event.preventDefault();\n    // event.stopPropagation();\n    if (this.state.firstTimeTyping)\n      this.setState({ firstTimeTyping: false });\n\n    this.setState({ justRevealed: true, typed: this.state.currentCard.back })\n  }\n\n  reportCorrectness() {\n    /* Flashes red or green on the page depending on input correctness */\n\n    // Don't accept input if card got revealed\n    if (this.state.justRevealed)\n      return;\n\n    let answer = this.state.currentCard.back;\n    let typed = this.state.typed.toLowerCase();\n\n    // Don't report if the first few characters are correct\n    if (typed.length < answer.length) {\n      if (typed === answer.slice(0, typed.length))\n        return\n    }\n\n    if (typed === this.state.currentCard.back) {\n      this.setState({ backgroundColor: \"#f6ffed\", border: \"1px solid #b7eb8f\" });\n      this.resetInputAfterTyping(true);\n    } else {\n      this.setState({ backgroundColor: \"#fff1f0\", border: \"1px solid #ffa39e\" });\n      this.resetInputAfterTyping(false);\n    }\n  }\n\n  resetInput(delay, nextCard) {\n    /* Used to create partial functions via method.bind() for callback */\n    if (nextCard) {\n      this.setState({\n        currentCard: this.cards[Math.floor(this.cards.length * Math.random())],\n        typed: \"\"\n      })\n    }\n    setTimeout(() => this.setState({ backgroundColor: this.defaultBackgroundColor, border: \"1px solid\" }), delay)\n    this.setState({ typed: \"\", typingTimer: null, justRevealed: false });\n  }\n\n  render() {\n    let card = this.state.currentCard;\n    let defaultText = this.state.firstTimeTyping ? \"type the phonetic translation\" : \"\";\n\n    let displayButton;\n    if (this.state.justRevealed)\n      displayButton = <Button type=\"default\" onClick={this.resetInputAfterReveal} \n        style={{backgroundColor: \"transparent\", margin: \"2%\"}}>continue</Button>;\n    else\n      displayButton = <Button type=\"default\" onClick={this.showAnswer} \n        style={{backgroundColor: \"transparent\", margin: \"2%\"}}>show</Button>\n\n    return (\n      <div align=\"center\">\n        <div class=\"Card\" style={{\n          backgroundColor: this.state.backgroundColor,\n          border: this.state.border,\n        }}>\n\n          <header style={{ fontSize: 20 }}>\n            A Flash Card Mini-Game for Japanese\n          </header>\n\n          <CardDisplay data={card.front}></CardDisplay>\n          <UserInputDisplay data={this.state.typed}\n            defaultText={defaultText}\n            textColor={this.state.textColor}\n            onChange={this.readForm}>\n          </UserInputDisplay>\n          <div>{displayButton}</div>\n\n        </div>\n      </div>\n    )\n  };\n}\n\nexport default FlashCardApp;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport FlashCardApp from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<FlashCardApp />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}