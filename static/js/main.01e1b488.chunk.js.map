{"version":3,"sources":["CardDisplay.js","UserInputDisplay.js","Button.js","App.js","serviceWorker.js","index.js"],"names":["CardDisplay","react_default","a","createElement","style","fontSize","margin","this","props","data","React","Component","UserInputDisplay","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","inputFieldStyle","backgroundColor","border","color","textColor","textAlign","autoFocus","placeholder","defaultText","value","onChange","ButtonStyling","background","padding","width","textDecoration","display","borderRadius","Button","onClick","text","Card","front","back","FlashCardApp","handleInput","bind","assertThisInitialized","reportCorrectness","readForm","showAnswer","resetInputAfterTyping","resetInput","resetInputAfterReveal","defaultColor","phonetic","cards","map","char","i","state","currentCard","Math","floor","length","random","showFront","typed","firstTimeTyping","window","addEventListener","removeEventListener","event","setState","curText","key","slice","test","typingTimer","clearTimeout","setTimeout","justRevealed","answer","toLowerCase","_this2","time","arguments","undefined","displayButton","card","displayData","src_Button","align","touchAction","src_CardDisplay","src_UserInputDisplay","Boolean","location","hostname","match","ReactDOM","render","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.01e1b488.chunk.js","sourcesContent":["import React from 'react';\n\nclass CardDisplay extends React.Component {\n    render(){\n        return (\n            <div style={{fontSize: 70, margin: \"20px\"}}>\n                {this.props.data}\n            </div>\n        )\n    }\n}\n\nexport default CardDisplay;","import React from 'react';\n\nclass UserInputDisplay extends React.Component {\n    constructor(props) {\n        super(props);\n        this.inputFieldStyle = {\n            backgroundColor: this.props.backgroundColor,\n            border: \"none\",\n            color: this.props.textColor,\n            margin: \"20px\",\n            fontSize: 20,\n            textAlign: \"center\"\n        }\n    }\n    render() {\n        return (\n            <input autoFocus\n                placeholder={this.props.defaultText}\n                value={this.props.data}\n                style={this.inputFieldStyle}\n                onChange={this.props.onChange}>\n            </input>\n        )\n    }\n}\n\nexport default UserInputDisplay;","import React from 'react';\n\nconst ButtonStyling = {\n    background: \"#777777\",\n    border: \"none\",\n    color: \"#DDDDDD\",\n    padding: \"15px\",\n    width: \"100px\",\n    textAlign: \"center\",\n    textDecoration: \"none\",\n    display: \"inline-block\",\n    fontSize: \"16px\",\n    borderRadius: \"5px\"\n}\n\nclass Button extends React.Component {\n    render(){\n        return (\n            <button onClick={this.props.onClick} style={ButtonStyling}>\n                {this.props.text || \"\"}\n            </button>\n        )\n    }\n}\n\nexport default Button;","import React from 'react';\nimport CardDisplay from './CardDisplay';\nimport UserInputDisplay from './UserInputDisplay';\nimport Button from './Button'\n\nclass Card {\n  constructor(front, back) {\n    this.front = front;\n    this.back = back;\n  }\n}\n\nclass FlashCardApp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handleInput = this.handleInput.bind(this);\n    this.reportCorrectness = this.reportCorrectness.bind(this);\n    this.readForm = this.readForm.bind(this);\n    this.showAnswer = this.showAnswer.bind(this);\n    this.resetInputAfterTyping = this.resetInput.bind(this, 500);\n    this.resetInputAfterReveal = this.resetInput.bind(this, 0, true);\n\n    this.defaultColor = \"#888888\"\n    const phonetic = ['a', 'i', 'u', 'e', 'o',\n      'ka', 'ki', 'ku', 'ke', 'ko',\n      'sa', 'shi', 'su', 'se', 'so',\n      'ta', 'chi', 'tsu', 'te', 'to',\n      'na', 'ni', 'nu', 'ne', 'no',\n      'ha', 'hi', 'fu', 'he', 'ho',\n      'ma', 'mi', 'mu', 'me', 'mo',\n      'ya', 'yu', 'yo',\n      'ra', 'ri', 'ru', 're', 'ro',\n      'wa', 'wo', 'n'\n    ];\n    const hirgana = ['あ', 'い', 'う', 'え', 'お',\n      'か', 'き', 'く', 'け', 'こ',\n      'さ', 'し', 'す', 'せ', 'そ',\n      'た', 'ち', 'つ', 'て', 'と',\n      'な', 'に', 'ぬ', 'ね', 'の',\n      'は', 'ひ', 'ふ', 'へ', 'ほ',\n      'ま', 'み', 'む', 'め', 'も',\n      'や', 'ゆ', 'よ',\n      'ら', 'り', 'る', 'れ', 'ろ',\n      'わ', 'を', 'ん'\n    ];\n    this.cards = hirgana.map((char, i) => new Card(char, phonetic[i]));\n    \n    this.state = {\n      currentCard: this.cards[Math.floor(this.cards.length * Math.random())],\n      showFront: true,\n      typed: \"\",\n      textColor: \"#000000\",\n      backgroundColor: this.defaultColor,\n      firstTimeTyping: true\n    }\n  }\n\n  componentDidMount() {\n    window.addEventListener(\"keydown\", this.handleInput);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"keydown\", this.handleInput);\n  }\n\n  handleInput(event) {\n    if (this.state.firstTimeTyping)\n      this.setState({ firstTimeTyping: false });\n\n    let curText = this.state.typed;\n    let isLetter = /^\\w$/;\n    if (event.key === \"Backspace\") {\n      if (curText.length > 0) {\n        this.setState({ typed: curText.slice(0, curText.length - 1) })\n      }\n    } else if (isLetter.test(event.key)) {\n      this.setState((state) => state.typed += event.key)\n    } else {\n      // Do not extend timer for input or report correctness\n      return;\n    }\n\n    // Extend the timer to recognize input if it exists, otherwise make one\n    if (this.state.typingTimer)\n      clearTimeout(this.state.typingTimer);\n    this.setState({ typingTimer: setTimeout(this.reportCorrectness, 300) });\n  }\n\n  readForm(event){\n    // Temp holder while using window.addEventListener(\"keydown\", this.handleInput);\n    // console.log(event.target.value);\n  }\n\n  showAnswer(){\n    if (this.state.firstTimeTyping)\n      this.setState({ firstTimeTyping: false });\n\n    this.setState({justRevealed: true, typed: this.state.currentCard.back})\n  }\n\n  reportCorrectness() {\n    let answer = this.state.currentCard.back;\n    let typed = this.state.typed.toLowerCase();\n\n    // Don't report if the first few characters are correct\n    if (typed.length < answer.length) {\n      if (typed === answer.slice(0, typed.length))\n        return\n    }\n\n    if (typed === this.state.currentCard.back) {\n      this.setState({ backgroundColor: \"#00BB00\" });\n      this.resetInputAfterTyping(true);\n    } else {\n      this.setState({ backgroundColor: \"#BB0000\" });\n      this.resetInputAfterTyping(false);\n    }\n  }\n\n  resetInput(time=0, nextCard){\n    if (nextCard) {\n      this.setState({\n        currentCard: this.cards[Math.floor(this.cards.length * Math.random())],\n        typed: \"\"\n      })\n    }\n    setTimeout(() => this.setState({ backgroundColor: this.defaultColor }), time)\n    this.setState({ typed: \"\", typingTimer: null , justRevealed: false});\n  }\n\n  render() {\n    let card = this.state.currentCard;\n    let displayData = this.state.showFront ? card.front : card.back;\n    let defaultText = this.state.firstTimeTyping ? \"type the phonetic translation\" : \"\";\n    let displayButton;\n    if (this.state.justRevealed)\n      displayButton = <Button text=\"continue\" onClick={this.resetInputAfterReveal}></Button>;\n    else\n      displayButton = <Button text=\"show\" onClick={this.showAnswer}></Button>\n\n    return (\n      <div align=\"center\" style={{ backgroundColor: this.state.backgroundColor, margin: \"10px\", touchAction: \"none\" }}>\n        \n        <header style={{ fontSize: 20 }}>\n          A Flash Card Mini-Game for Hiragana\n        </header>\n\n        <CardDisplay data={displayData}></CardDisplay>\n        <UserInputDisplay data={this.state.typed}\n          defaultText={defaultText}\n          textColor={this.state.textColor}\n          backgroundColor={this.state.backgroundColor}\n          onChange={this.readForm}>\n        </UserInputDisplay>\n        <div>{displayButton}</div>\n\n      </div>\n    )\n  };\n}\n\nexport default FlashCardApp;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport FlashCardApp from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<FlashCardApp />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}